{"ast":null,"code":"import _classCallCheck from \"@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"@babel/runtime-corejs2/helpers/esm/inherits\";\nvar _jsxFileName = \"/Users/malcolmmcswain/Desktop/honors/ml-models/pages/index.js\";\nimport React from 'react';\nimport * as tf from '@tensorflow/tfjs';\n\nvar Home =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(Home, _React$Component);\n\n  function Home() {\n    _classCallCheck(this, Home);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Home).apply(this, arguments));\n  }\n\n  _createClass(Home, [{\n    key: \"render\",\n\n    /*\n    async getData() {\n      const carsDataReq = await fetch('https://storage.googleapis.com/tfjs-tutorials/carsData.json');\n      const carsData = await carsDataReq.json();\n      const cleaned = carsData.map(car => ({\n        mpg: car.Miles_per_Gallon,\n        horsepower: car.Horsepower,\n      })).filter(car => (car.mpg != null && car.horsepower != null));\n       return cleaned;\n    }\n     createModel() {\n      const model = tf.sequential({\n        layers: [\n          tf.layers.dense({inputShape: [1], units: 16, useBias: true}),\n          tf.layers.dense({units: 50, activation: 'relu'}),\n          tf.layers.dense({units: 50, activation: 'sigmoid'}),\n          tf.layers.dense({units: 1, useBias: true}),\n        ]\n      });\n       return model;\n    }\n     convertToTensor(data) {\n      return tf.tidy(() => {\n        tf.util.shuffle(data);\n         const inputs = data.map(d => d.horsepower);\n        const labels = data.map(d => d.mpg);\n         const inputTensor = tf.tensor2d(inputs, [inputs.length, 1]);\n        const labelTensor = tf.tensor2d(labels, [labels.length, 1]);\n         const inputMax = inputTensor.max();\n        const inputMin = inputTensor.min();\n        const labelMax = labelTensor.max();\n        const labelMin = labelTensor.min();\n         const normalizedInputs = inputTensor.sub(inputMin).div(inputMax.sub(inputMin));\n        const normalizedLabels = labelTensor.sub(labelMin).div(labelMax.sub(labelMin));\n         return {\n          inputs: normalizedInputs,\n          labels: normalizedLabels,\n          inputMax,\n          inputMin,\n          labelMax,\n          labelMin,\n        }\n      })\n    }\n     async trainModel(model, inputs, labels) {\n      model.compile({\n        optimizer: tf.train.adam(),\n        loss: tf.losses.meanSquaredError,\n        metrics: ['mse'],\n      });\n       const batchSize = 28;\n      const epochs = 100;\n       return await model.fit(inputs, labels, {\n        batchSize,\n        epochs,\n        shuffle: true,\n        callbacks: tfvis.show.fitCallbacks(\n          { name: 'Training Performance' },\n          ['loss', 'mse'],\n          {\n            height: 200,\n            callbacks: ['onEpochEnd']\n          }\n        )\n      });\n    }\n     testModel(model, inputData, normalizationData) {\n      const {inputMax, inputMin, labelMin, labelMax} = normalizationData;\n       const [xs, preds] = tf.tidy(() => {\n        const xs = tf.linspace(0, 1, 100);\n        const preds = model.predict(xs.reshape([100, 1]));\n         const unNormXs = xs.mul(inputMax.sub(inputMin)).add(inputMin);\n        const unNormPreds = preds.mul(labelMax.sub(labelMin)).add(labelMin);\n         return [unNormXs.dataSync(), unNormPreds.dataSync()];\n      });\n       const predictedPoints = Array.from(xs).map((val, i) => {\n        return {x: val, y: preds[i]}\n      });\n       const originalPoints = inputData.map(d => ({\n        x: d.horsepower,\n        y: d.mpg,\n      }));\n       tfvis.render.scatterplot(\n        {name: 'Model Predictions vs Original Data'},\n        {values: [originalPoints, predictedPoints], series: ['original', 'predicted']},\n        {\n          xLabel: 'Horsepower',\n          yLabel: 'MPG',\n          height: 300\n        }\n      );\n    }\n     run() {\n       const data = await getData();\n      const values = data.map(d => ({\n        x: d.horsepower,\n        y: d.mpg,\n      }));\n       const model = createModel();\n      const surface = { name: 'Model Summary', tab: 'Model Inspection' };\n      tfvis.show.modelSummary(surface, model);\n       /*tfvis.render.scatterplot(\n        {name: 'Horsepower v MPG'},\n        {values},\n        {\n          xLabel: 'Horsepower',\n          yLabel: 'MPG',\n          height: 300\n        }\n      );\n       const tensorData = convertToTensor(data);\n      const {inputs, labels} = tensorData;\n       await trainModel(model, inputs, labels);\n      console.log('Done Training');\n       testModel(model, data, tensorData);\n    }\n     componentDidMount() {\n      this.run()\n    }\n    */\n    value: function render() {\n      return React.createElement(\"h1\", {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 154\n        },\n        __self: this\n      }, \"Hello world!\");\n    }\n  }]);\n\n  return Home;\n}(React.Component);\n\nexport default Home;","map":{"version":3,"sources":["/Users/malcolmmcswain/Desktop/honors/ml-models/pages/index.js"],"names":["React","tf","Home","Component"],"mappings":";;;;;;AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,OAAO,KAAKC,EAAZ,MAAoB,kBAApB;;IAEMC,I;;;;;;;;;;;;;;AACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6BAmJS;AACP,aACE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,wBADF;AAID;;;;EAzJgBF,KAAK,CAACG,S;;AA4JzB,eAAeD,IAAf","sourcesContent":["import React from 'react'\nimport * as tf from '@tensorflow/tfjs'\n\nclass Home extends React.Component {\n  /*\n  async getData() {\n    const carsDataReq = await fetch('https://storage.googleapis.com/tfjs-tutorials/carsData.json');\n    const carsData = await carsDataReq.json();\n    const cleaned = carsData.map(car => ({\n      mpg: car.Miles_per_Gallon,\n      horsepower: car.Horsepower,\n    })).filter(car => (car.mpg != null && car.horsepower != null));\n\n    return cleaned;\n  }\n\n  createModel() {\n    const model = tf.sequential({\n      layers: [\n        tf.layers.dense({inputShape: [1], units: 16, useBias: true}),\n        tf.layers.dense({units: 50, activation: 'relu'}),\n        tf.layers.dense({units: 50, activation: 'sigmoid'}),\n        tf.layers.dense({units: 1, useBias: true}),\n      ]\n    });\n\n    return model;\n  }\n\n  convertToTensor(data) {\n    return tf.tidy(() => {\n      tf.util.shuffle(data);\n\n      const inputs = data.map(d => d.horsepower);\n      const labels = data.map(d => d.mpg);\n\n      const inputTensor = tf.tensor2d(inputs, [inputs.length, 1]);\n      const labelTensor = tf.tensor2d(labels, [labels.length, 1]);\n\n      const inputMax = inputTensor.max();\n      const inputMin = inputTensor.min();\n      const labelMax = labelTensor.max();\n      const labelMin = labelTensor.min();\n\n      const normalizedInputs = inputTensor.sub(inputMin).div(inputMax.sub(inputMin));\n      const normalizedLabels = labelTensor.sub(labelMin).div(labelMax.sub(labelMin));\n\n      return {\n        inputs: normalizedInputs,\n        labels: normalizedLabels,\n        inputMax,\n        inputMin,\n        labelMax,\n        labelMin,\n      }\n    })\n  }\n\n  async trainModel(model, inputs, labels) {\n    model.compile({\n      optimizer: tf.train.adam(),\n      loss: tf.losses.meanSquaredError,\n      metrics: ['mse'],\n    });\n\n    const batchSize = 28;\n    const epochs = 100;\n\n    return await model.fit(inputs, labels, {\n      batchSize,\n      epochs,\n      shuffle: true,\n      callbacks: tfvis.show.fitCallbacks(\n        { name: 'Training Performance' },\n        ['loss', 'mse'],\n        {\n          height: 200,\n          callbacks: ['onEpochEnd']\n        }\n      )\n    });\n  }\n\n  testModel(model, inputData, normalizationData) {\n    const {inputMax, inputMin, labelMin, labelMax} = normalizationData;\n\n    const [xs, preds] = tf.tidy(() => {\n      const xs = tf.linspace(0, 1, 100);\n      const preds = model.predict(xs.reshape([100, 1]));\n\n      const unNormXs = xs.mul(inputMax.sub(inputMin)).add(inputMin);\n      const unNormPreds = preds.mul(labelMax.sub(labelMin)).add(labelMin);\n\n      return [unNormXs.dataSync(), unNormPreds.dataSync()];\n    });\n\n    const predictedPoints = Array.from(xs).map((val, i) => {\n      return {x: val, y: preds[i]}\n    });\n\n    const originalPoints = inputData.map(d => ({\n      x: d.horsepower,\n      y: d.mpg,\n    }));\n\n    tfvis.render.scatterplot(\n      {name: 'Model Predictions vs Original Data'},\n      {values: [originalPoints, predictedPoints], series: ['original', 'predicted']},\n      {\n        xLabel: 'Horsepower',\n        yLabel: 'MPG',\n        height: 300\n      }\n    );\n  }\n\n  run() {\n\n    const data = await getData();\n    const values = data.map(d => ({\n      x: d.horsepower,\n      y: d.mpg,\n    }));\n\n    const model = createModel();\n    const surface = { name: 'Model Summary', tab: 'Model Inspection' };\n    tfvis.show.modelSummary(surface, model);\n\n    /*tfvis.render.scatterplot(\n      {name: 'Horsepower v MPG'},\n      {values},\n      {\n        xLabel: 'Horsepower',\n        yLabel: 'MPG',\n        height: 300\n      }\n    );\n\n    const tensorData = convertToTensor(data);\n    const {inputs, labels} = tensorData;\n\n    await trainModel(model, inputs, labels);\n    console.log('Done Training');\n\n    testModel(model, data, tensorData);\n  }\n\n  componentDidMount() {\n    this.run()\n  }\n  */\n  render() {\n    return (\n      <h1>Hello world!</h1>\n\n    )\n  }\n}\n\nexport default Home\n"]},"metadata":{},"sourceType":"module"}